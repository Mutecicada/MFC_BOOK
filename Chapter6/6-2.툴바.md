# 툴바
- 메뉴 항목의 기능을 빠르게 수행하려는 목적으로 사용되며, 메뉴 항목에 없는 기능을 독립적으로 제공하기도 한다.

- `CToolBar`와 `CControlBar` 두 개의 클래스를 이용하여 다룰 수 있다.

<br><br>

# 툴바 생성
- 툴바 리소스를 이용하여 생성한다.

## 툴바 리소스
- 툴바 리소스는 일종의 비트맵으로, 버튼 모양의 그림이 연속적으로 배치되어 있다. 

- 툴바의 속성 항목은 다음과 같다.
    - ID : 메뉴 항목과 같은 ID를 주거나 새로운 ID를 부여한다.
    - Prompt : 메뉴 항목의 Prompt 속성처럼 여기에 입력한 내용이 상태바와 툴팁에 표시된다.
    - Height, Width : 툴바 버튼의 크기를 폭과 높이로 나타내는데, 버튼 한 개의 값을 변경하면 전체 툴바의 크기가 바뀐다.


## 툴바 코드
```C++
class CMainFrame : public CFrameWnd
{
    // ....

  protected:
   CToolBar     m_wndToolBar;
   CStatusBar   m_wndSatusBar;
   CChildView   m_wndView;
   // ....
};
```
- 툴바는 프레임 윈도우에서 관리하며 툴바나 상태바의 존재 여부에 따라 뷰의 크기는 자동으로 조정된다.

- 프로그램 마법사를 통해 생성된 프로젝트에 MainFrm.h 파일에 선언되어 있는 ToolBar 객체이다.

```C++
int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if(!m_wndToolBar.CreateEx(this, TBSTLE_FLAT,
    WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_GRIPPER |
    CBRS_TOOLTIP | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
    !m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
    {
        TRACE0("도구 모음을 만들지 못했습니다.\n");
        return -1;
    }
// ...

    m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
    EnableDocking(CBRS_ALIGN_ANY);
    DockControlBar(&m_wndToolBar);

    return 0;
}
```

- CToolBar::CreateEx() - 툴바를 운영체제 수준에서 생성한 후 C++ 툴바 객체와 연결한다.<br> 첫 번째 인자인 this 포인터는 프레임 윈도우 객체를 가리키며 툴바가 프레임 윈도우의 자식 윈도우로 생성됨을 나타낸다.

- CToolBar::LoadToolBar() - 툴바 리소스를 로드한다.

- CControlar::EnableDocking() - 툴바가 클라이언트 영역 중 어느 위치에 붙을 수 있는지 결정한다.

- CFrameWnd::EnableDocking() - 프레임 윈도우가 자신의 클라이언트 영역 어느 위치에 툴바를 붙일 수 있을지 결정한다.

- CFrameWnd::DOckControlBar() - 툴바를 프레임 윈도우에 실제로 붙인다.


<br><br>

# 툴바 사용
- 메뉴의 명령 항목 처럼 `WM_COMMAND` 메시지가 발생한다.

- 속성 창을 이용해 `명령 핸들러`를 작성하면 명령을 처리할 수 있다.

- 메뉴 항목에 해당하는 명령 핸들러를 이미 작성한 상태에서 툴바 버튼에 메뉴 항목과 동일한 ID를 부여하면 따로 명령 핸들러를 작성할 필요가 없다.

- 메뉴 항목의 명령 갱신 핸들러를 작성했다면 툴바에서도 자동으로 작동된다.