# 직렬화(Serialization)
- 영속적인 저장 매체(디스크 파일 등)에 객체의 내용을 저장하거나 읽어오는 기법이다.

- 일반적으로 직렬화는 일반 파일IO보다 CArchive 클래스를 이용한 입출력 기법을 말한다.

## 직렬화 기초

```C++
CFile file;
CFileEception e;
if(!file.Open(_T("mytest.dat"), CFile::modeWrite | CFile::modeCreate, &e))
{
    e.ReportError();
    return;
}
double a = 1.23;
double b = 4.56;

CArchive ar(&file, CArchive::store);
ar << a << b;
```

```C++
double a, b;
CArchive ar(&file, CArchive::load);
ar >> a >> b;
```
- <<, >> 연산자로 파일 입출력을 할 수 있다.

- CArchive 객체를 이용하더라도 궁극적으로 디스크 파일과 연관된 CFile 객체가 필요하다.

```C++
CArchive::CArhive(CFile* pFile, UINT nMode, int nBUfSize=4096, void*lpBuf=NULL);
```
- pFile : 데이터를 저장하거나 읽어들일 파일과 연관된 CFile 객체이다.(필수 인자)
- nMode : 객체를 저장할 것인지 혹은 읽을 것인지를 나타내는 값으로 CArchive::load 또는 CArchive::store를 사용한다.(필수 인자)
- nBufSize = CArchive 클래스 내부에서 사용할 버퍼 크기다. <br>CArchive 클래스는 CFile 클래스와 달리 내부적으로 입출력 데이터를 버퍼링한다.(기본값 : 4096 Byte)

- lpBuf : 사용자 정의 버퍼의 주소값으로, 기본값 NULL을 사용하면 힙에서 버퍼를 위한 메모리가 자동 할당된다.

- 특정 파일과 연관된 CArchive 객체를 만들었으면 이후부터 << 또는 >> 연산자로 직렬화를 할 수 있다.<br> 자주 사용되는 데이터 타입은 MFC에서 미리 연산자 오버로딩 해두었으므로 곧바로 직렬화 기법을 적용할 수 있다.

<br><br>

# 도큐먼트 / 뷰 구조와 직렬화

## [파일] - [열기] 
```c++
ON_COMMAND(ID_FILE_OPEN, &CWinApp::OnFileOpen)
```
1. 메시지 맵 항목에 따라 `CWinApp::OnFileOpen()` 함수가 자동으로 호출되고, `[열기]` 대화 상자가 나타난다.

2. 사용자가 파일을 선택하면 `CWinApp::OnFileOpen()` 함수는 이 파일의 경로명을 내부에 저장해둔다.

3. 여러 개의 MFC 내부 함수 호출을 따라가면 `CDocument::OnOpenDocumnet()` 함수에 도달한다.

4. `OnOpenDocument()` 함수에서는 다음 코드와 같이 사용자가 선택한 파일과 연관된 `CFile` 객체를 만들고 `CArchive` 객체를 생성한 후 `CDocument::Serialize()` 함수를 호출한다.

5. 만약 `재정의된` Serialize() 함수가 있다면 대신으로 자동 호출된다.

```c++
BOOL CDocument::OnOpenDocument(LPCTSTR lpszPathName)
{
    // CFile 객체를 생성한다. pFile은 CFile 객체의 주소값을 담고 있다.
    CArchive ar(pFile, CArchive::load | CArchive::bNoFlushOnDelete);

    Serialize(ar);
}

## [파일] - [저장], [파일] - [다른 이름으로 저장]
- `CDocument` 클래스 내에 메시지 맵 항목이 들어 있다.
```C++
ON_COMMAND(ID_FILE_SAVE, OnFileSave);
ON_COMMAND(ID_FILE_SAVE_AS, OnFileSaveAs)
```

1. 메시지 맵에 따라 `CDocument::OnFileSave()` 또는 `CDocument::OnFileSaveAs()` 함수가 자동으로 호출되며, [다른 이름으로 저장] 대화 상자가 열린다.

2. 사용자가 저장할 위치를 선택하고 파일명을 입력하면 두 함수는 사용자가 입력한 내용을 내부에 저장해 둔다.

3. 이후 여러 개의 MFC 내부 함수 호출을 따라가면 `CDocument::OnSaveDocument()` 함수에 도달한다.

4. `OnSaveDocument()` 함수에서는 다음 코드와 같이 사용자가 저장할 파일과 연관된 `CFile 객체`를 만들고 `CArchive 객체`를 생성한 후 CDocument::Serialize() 함수를 호출한다.

5. 마찬가지로 `재정의된 Serialize()` 함수가 있으면 자동으로 호출된다.

```C++
BOOL CDocument::OnSaveDocument(LPCTSTR lpszPathName)
{
    // (CFile) 객체를 생성한다; pFile은 CFile 객체의 주소값을 담고 있다.

    CArchive ar(pFile, CArchive::store | CArchive::bNoFlushOnDelete);

    Serialize(ar);
}
```

### 요약
- CFile 객체와 CArchive 객체를 만드는 작업을 MFC에서 자동으로 해준다.

- 프로그래머가 할 일은 도큐먼트 클래스의 Serialize() 함수를 재정의하여, 어떤 데이터를 저장하고 읽을 것인지 코딩하는 것이다.

- 응용 프로그램 마법사가 자동 새성한 Serialize() 함수의 형태는 다음과 같다.

- CArhive객체가 생성될 때 인자로 CArchive::store를 사용했다면 CArchive::IsStoring() 함수는 TRUE를, 그렇지 않은 경우는 FALSE를 리턴한다.

```c++
void CFileIOTestDoc::Serialize(CArchive& ar)
{
    if(ar.IsStoring())
    {
        // 저장 코드를 추가합니다.
    }
    else
    {
        // 여기에 로딩 코드를 추가합니다.
    }
}
```

<br><br>

# 직렬화 클래스 구현
```C++
class CMyData
{
    public:
        CString m_str;
        COLORREF m_color;
    public:
    CMyData(CString &str, COLORREF &color) { m_str = str; m_color = color; }
    virtual ~CMyData();
};
```
- MFC에서 정의한 데이터 타입은 쉽게 직렬화할 수 있지만, 사용자가 정의한 데이터 타입은 곧바로 직렬화할 수 없다.

```C++
class CMyData : public CObject
{
    DECLARE_SERIAL(CMyData)
    public:
        CString m_str;
        COLORREF m_color;
    public:
    CMyData() {}
    CMyData(CString &str, COLORREF &color) { m_str = str; m_color = color; }
    virtual ~CMyData();
    void Serialize(CArchive& ar);
};

// 클래스 구현부
IMPLEMENT_SERIAL(CMyData, CObject, 1)

void CMyData::Serialize(CArchive& ar)
{
    CObject::Serialize(ar);
    if(ar.IsStoring())
        ar << m_str << m_color;
    else
        ar >> m_str >> m_color;
}
```

1. 직렬화 기능을 사용하려면 최상위 클래스에 CObject가 있어야 한다. 
    - CObject를 상속받아도 되고, CObject를 최상위 클래로 하는 다른 클래스를 상속 받아도 된다.

2. CObject 클래스를 상속받는다고 해서 직렬화 기능을 사용할 수 있는 것은 아니다.
    - DECLARE_SERIAL(클래스 이름), IMPLEMENT_SERIAL(클래스 이름, 상위 클래스 이름, 버전) 의 매크로가 있어야 한다.
    - 매크로에서 버전은 1로 시작하는 것이 좋고, 새로운 데이터가 추가되면 버전을 높여야 한다.

3. 반드시 기본 생성자가 있어야 한다.

4. CObject 클래스가 제공하는 Serialize() 함수를 자신의 클래스에 맞게 재정의한다.
    - 상위 클래스의 Serialize() 함수를 먼저 호출한 후 자신의 데이터를 직렬화 해야한다.

```C++

void CFileIOTestDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
        ar << m_data;
	}
	else
	{
        ar >> m_data;
	}
}

```